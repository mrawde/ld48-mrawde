PlayLevel
════════════════════════════════════════════════════════════════════════

let level_state
let level_element
let player_state
let input_block

def init_level_state(level):
    let level_state = deep_clone(level)
    const num_tiles = level_state.size.x * level_state.size.y
    level_state.visited = []
    for i < num_tiles:
        push(level_state.visited, false)
    return level_state
    
def init_level_element(level_state):
    let level_elem = {
        state: level_state,
        trucks: [],
    }
    for i < size(level_state.trucks):
        const truck = level_state.trucks[i]
        let truck_elem = {
            which: i,
            offset: xy(0, 0),
            angle: 0°,
            state: truck,
            anim: "idle",
        }
        push(level_elem.trucks, truck_elem)
    
    return level_elem
        
def screen_to_board_coord(screen_xy):
    const offset = BOARD_OFFSET
    return floor((screen_xy - offset) / TILE_SIZE)

def copy_level_state(level_state):
    return deep_clone(level_state)

def update_curr_path(level_state, player_state):
    let path = player_state.path
    if size(path) == 0:
        player_state.last_path = []
        return

    if is_long_press():
        // look at the current
        const coord = screen_to_board_coord(cursor_hover)
        
        if (is_truck_at_goal(level_state, player_state.curr_truck) 
            or not is_coord_valid_for_move(level_state, coord)):
            return
        
        todo("don't let path move through goal")
        const last_coord = last_value(path)
        if manhattan(last_coord - coord) == 1:
            let found = find_eq(path, coord)
            if found ≠ ∅:
                if found == size(path)-2:
                    pop(path)
            else:
                push(path, coord)

    else:
        player_state.last_path = path
        player_state.path = []
    
def handle_player_input(gamepad):
    let actions = {}
    
    let button_offset = xy(BUTTONS_OFFSET)
    const button_spacing = 1.1 * BUTTON_SIZE.x
    const clicked_next_truck = button_state({
        corner: button_offset,
        size: BUTTON_SIZE,
        text: replace("Next (d)", gamepad.prompt),
    }).clicked
    button_offset.x += button_spacing
    const clicked_undo = button_state({
        corner: button_offset,
        size: BUTTON_SIZE,
        text: replace("Undo (e)", gamepad.prompt),
    }).clicked
    button_offset.x += button_spacing
    const clicked_reset = button_state({
        corner: button_offset,
        size: BUTTON_SIZE,
        text: replace("Reset (q)", gamepad.prompt),
    }).clicked
    button_offset.x += button_spacing    
    
    if input_block.flag:
        return actions
    
    if is_click():
        const coord = screen_to_board_coord(cursor_hover)
        actions.select = coord
    
    let long_ended = long_press_ended()
    if long_ended:
        actions.select = screen_to_board_coord(long_ended.start_pos)
        const coord = screen_to_board_coord(cursor_hover)
        actions.move_path = true
    else if is_long_press():
        actions.pathing = true
        
    if gamepad.xx or gamepad.yy:
        actions.move = x_or_y(xy(gamepad.xx, gamepad.yy))
        
    if clicked_next_truck or gamepad.dd:
        actions.next_player = true
         
    if clicked_undo or gamepad.ee:
        actions.undo = true
       
    if clicked_reset or gamepad.qq:
        actions.reset_level = true
            
    return actions
    
def update_state(level_elem, player_state, actions):
    const level_state = level_elem.state
    if actions.reset_level:
        set_mode(PlayLevel, player_state.undo_stack[0])

    const start_path = actions.pathing and size(player_state.path) == 0
    if actions.next_player or actions.select or start_path:
        let player_idx
        if actions.next_player:
            player_idx = (player_state.curr_truck + 1) mod size(level_state.trucks)
        else if actions.select or start_path:
            let select_coord = actions.select
            if not select_coord:
                select_coord = screen_to_board_coord(curr_drag.start_pos)
                
            const trucks = level_state.trucks
            for i < size(trucks):
                const truck = trucks[i]
                if eq(select_coord, truck.coord):
                    player_idx = i
    
        if player_idx ≠ ∅:
            if player_state.curr_truck ≠ player_idx:
                const last_state = last_value(player_state.undo_stack)
                if not eq_recursive(level_state, last_state):
                    push(player_state.undo_stack, copy_level_state(level_state))
                player_state.curr_truck = player_idx
                
    const curr_truck_elem = level_elem.trucks[player_state.curr_truck]

    if start_path:
        const start_coord = screen_to_board_coord(curr_drag.start_pos)
        if eq(start_coord, curr_truck_elem.state.coord):
            push(player_state.path, start_coord)

    if actions.move_path or actions.move:
        if actions.move_path:
            move_path(input_block, level_elem, curr_truck_elem, player_state.last_path)
        else:
            const curr_truck_elem = level_elem.trucks[player_state.curr_truck]
            let dest_coord = actions.move_path
            if not dest_coord:
                const move_dir = actions.move
                dest_coord = curr_truck_elem.state.coord + move_dir
    
            if can_move(level_state, player_state, dest_coord):
                move_path(input_block, level_elem, curr_truck_elem, [
                    curr_truck_elem.state.coord,
                    dest_coord,
                ])

def move_path(input_block, level_elem, truck_elem, path):
    if size(path) < 2:
        return
    
    input_block.flag += 1

    let moves = []

    let last = path[0]
    assert(eq(last, truck_elem.state.coord))
    for 0 < i < size(path):
        let curr = path[i]
        const dir = curr-last
        extend(moves, sequence_move(level_elem, truck_elem, dir))
        last = curr
    
    def move_path_done(data):
        data.input_block.flag -= 1
        
    sequence(...moves,
    {
        end_callback: move_path_done,
        frames: 1,
        data: {
            input_block: input_block,
        },
    })

def angle_for_dir(dir):
    if eq(dir, xy(1, 0)):
        return 0°
    if eq(dir, xy(0, -1)):
        return 90° 
    if eq(dir, xy(-1, 0)):
        return 180° 
    if eq(dir, xy(0, 1)):
        return 270°

def shorter_angle_diff(a, b):
    // assumes both a and b are [0, 360)
    let diff = a - b
    while diff > 360°:
        diff -= 360°
    while diff < -360°:
        diff += 360°
        
    if diff > 180°:
        diff -= 360°
    else if diff < -180°:
        diff += 360°
        
    return diff
        

def sequence_move(level_elem, truck_elem, dir):
    
    const target_angle = angle_for_dir(dir)
    
    const start_offset = -dir * TILE_SIZE
    
    def move_enter(data):
        const start_offset = data.start_offset
        const level_state = data.level_state
        const truck_elem = data.truck_elem
        const target_angle = data.target_angle
        level_state.visited[to_index(level_state.size, truck_elem.state.coord)] = true
        truck_elem.state.coord += data.dir
        truck_elem.offset = start_offset
        truck_elem.angle = target_angle
        truck_elem.anim = "running"
    
    def move_frame(frames_left, total_frames, data):
        const t = smoothstep(total_frames, 0, frames_left)
        let truck_elem = data.truck_elem
        const start_offset = data.start_offset
        truck_elem.offset = lerp(start_offset, xy(0, 0), t)
        
    def move_leave(data):
        truck_elem.anim = "idle"
        
    const move_data = {
        truck_elem: truck_elem,
        level_state: level_elem.state,
        target_angle: target_angle,
        dir: dir,
        start_offset: start_offset,
    }
    
    return [
        {
            end_callback: move_enter,
            frames: 1,
            data: move_data,
        },
        {
            callback: move_frame,
            end_callback: move_leave,
            frames: FRAMES_MOVE,
            data: move_data,
        },
    ]
    

enter(level_state_)
────────────────────────────────────────────────────────────────────────
set_background(GROUND_COLOR)
device_control("set_mouse_cursor", "none")

player_state = {
    curr_truck: 0,
    undo_stack: [],
    path: [],
    last_path: [],
}

input_block = {
    flag: 0,
}

if level_state_:
    level_state = level_state_
else:
    if game_progress.done:
        set_mode(GameOver)
    else:
        const pack = PACKS[game_progress.curr_pack_idx]
        const level = pack.levels[game_progress.curr_level_idx]
        level_state = init_level_state(level)
    
push(player_state.undo_stack, copy_level_state(level_state))
level_element = init_level_element(level_state)

frame
────────────────────────────────────────────────────────────────────────

update_cursor_hover()
draw_mouse_cursor()

update_curr_path(level_state, player_state)

let actions = handle_player_input(gamepad_array[0])

if actions.undo:
    while (eq_recursive(level_state, last_value(player_state.undo_stack)) 
        and size(player_state.undo_stack) > 1):
        pop(player_state.undo_stack)
        
    if size(player_state.undo_stack) > 1:
        level_state = pop(player_state.undo_stack)
    else:
        level_state = copy_level_state(last_value(player_state.undo_stack))
    level_element = init_level_element(level_state)

if not input_block.flag:
    check_level(level_state)      
    
update_state(level_element, player_state, actions)
draw_game(level_element, player_state)

update_curr_drag()