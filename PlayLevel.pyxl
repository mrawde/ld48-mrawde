PlayLevel
════════════════════════════════════════════════════════════════════════

let level_state
let player_state

const COLORS = [
    #f00,
    #0f0,
    #00f,
    #0ff,
    #f0f,
    #ff0,
]
const HUD_LEVEL_FONT = font

def init_level_state(level):
    let level_state = deep_clone(level)
    const num_tiles = level_state.size.x * level_state.size.y
    level_state.visited = []
    for i < num_tiles:
        push(level_state.visited, false)
    return level_state
        
def screen_to_board_coord(screen_xy):
    const offset = BOARD_OFFSET
    return floor((screen_xy - offset) / TILE_SIZE)

def copy_level_state(level_state):
    return deep_clone(level_state)
    
def handle_player_input(gamepad):
    let actions = {}
    if is_click():
        const coord = screen_to_board_coord(cursor_hover)
        actions.select = coord
        
    if is_long_press():
        actions.select = screen_to_board_coord(curr_drag.start_pos)

        const coord = screen_to_board_coord(cursor_hover)
        actions.move_to = coord
        
    if gamepad.xx or gamepad.yy:
        actions.move = x_or_y(xy(gamepad.xx, gamepad.yy))
        
    if gamepad.dd:
        actions.next_player = true
        
    if gamepad.qq:
        actions.reset_level = true
        
    if gamepad.ee:
        actions.undo = true
            
    return actions
    
def update_state(level_state, player_state, actions):
    if actions.reset_level:
        set_mode(PlayLevel, player_state.undo_stack[0])
        
    if actions.next_player or actions.select:
        let player_idx
        if actions.next_player:
            player_idx = (player_state.curr_truck + 1) mod size(level_state.trucks)
        else if actions.select:
            const trucks = level_state.trucks
            for i < size(trucks):
                const truck = trucks[i]
                if eq(actions.select, truck.coord):
                    player_idx = i
    
        if player_idx ≠ ∅:
            if player_state.curr_truck ≠ player_idx:
                const last_state = last_value(player_state.undo_stack)
                if not eq_recursive(level_state, last_state):
                    push(player_state.undo_stack, copy_level_state(level_state))
                player_state.curr_truck = player_idx

    if actions.move_to or actions.move:
        const curr_truck = level_state.trucks[player_state.curr_truck]
        let dest_coord = actions.move_to
        if not dest_coord:
            const move_dir = actions.move
            dest_coord = curr_truck.coord + move_dir

        if can_move(level_state, player_state, dest_coord):
            const curr_i = to_index(level_state.size, curr_truck.coord)
            level_state.visited[curr_i] = true
            curr_truck.coord = dest_coord       
        

enter(level_state_)
────────────────────────────────────────────────────────────────────────
player_state = {
    curr_truck: 0,
    undo_stack: [],
}

if level_state_:
    level_state = level_state_
else:
    if game_progress.done:
        set_mode(GameOver)
    else:
        const pack = PACKS[game_progress.curr_pack_idx]
        const level = pack.levels[game_progress.curr_level_idx]
        level_state = init_level_state(level)
    
push(player_state.undo_stack, copy_level_state(level_state))
set_background(BACKGROUND_COLOR)


frame
────────────────────────────────────────────────────────────────────────

update_cursor_hover()
draw_rect({
    pos: cursor_hover,
    size: xy(5, 5),
    color: #333,
})

check_level(level_state)
let actions = handle_player_input(gamepad_array[0])

if actions.undo:
    while (eq_recursive(level_state, last_value(player_state.undo_stack)) 
        and size(player_state.undo_stack) > 1):
        pop(player_state.undo_stack)
        
    if size(player_state.undo_stack) > 1:
        level_state = pop(player_state.undo_stack)
    else:
        level_state = copy_level_state(last_value(player_state.undo_stack))
        
update_state(level_state, player_state, actions)
draw_game(level_state, player_state)

update_curr_drag()